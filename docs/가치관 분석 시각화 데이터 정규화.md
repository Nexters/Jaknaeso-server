# 가치관 분석 시각화 데이터 정규화

> 해당 문서는 실제 코드에서 사용되는 식이 아닌, 새로운 식을 제안하는 문서입니다.

## 📄 **설문 응답 점수 정규화 과정**

---

### 📝 **문제 정의**
설문 응답 선택지에 **키워드(Keyword)**와 **점수(Score)**가 매핑되어 있음.  
각 설문 응답 결과를 통해 **정규화된 통계 지표**를 만들고자 함.

---

### 📊 **예시 데이터**

설문의 응답이 3개 존재한다고 가정:

| 응답 번호 | KeywordScore |
|:---------:|:------------:|
| 1번       | (성공, 1), (안전, -1) |
| 2번       | (보편, 1) |
| 3번       | (성공, 1), (보편, 2) |

---

### 🧮 **정규화 절차**

#### **1️⃣ 모든 응답의 KeywordScore 합산**

각 키워드별 점수 합산:

```
성공 = 1 (1번) + 1 (3번) = 2
안전 = -1 (1번)
보편 = 1 (2번) + 2 (3번) = 3
```

👉 **합산 결과**: `[(성공, 2), (안전, -1), (보편, 3)]`

---

#### **2️⃣ Min-Max 정규화 (0 ~ 1 스케일)**

- **최소값**: `min = -1` (안전)
- **최대값**: `max = 3` (보편)

정규화 공식:

```
정규화 값 = (점수 - 최소값) / (최대값 - 최소값)
```

##### 각 키워드 정규화 계산
```
성공: (2 - (-1)) / (3 - (-1)) = 3/4 = 0.75
안전: (-1 - (-1)) / (3 - (-1)) = 0/4 = 0.00
보편: (3 - (-1)) / (3 - (-1)) = 4/4 = 1.00
```

👉 **정규화 결과**: `[(성공, 0.75), (안전, 0.00), (보편, 1.00)]`

---

#### **3️⃣ 0 ~ 100 스케일로 변환**

스케일링 공식:

```
스케일 값 = 정규화 값 × 100
```

##### 각 키워드 스케일 계산
```
성공: 0.75 × 100 = 75%
안전: 0.00 × 100 = 0%
보편: 1.00 × 100 = 100%
```

👉 **최종 결과**: `[(성공, 75%), (안전, 0%), (보편, 100%)]`

---

### ✅ **최종 정리**

| 키워드 | 합산 점수 | 정규화 값 (0~1) | 스케일 값 (0~100) |
|:------:|:---------:|:----------------:|:-----------------:|
| 성공   | 2         | 0.75             | 75%               |
| 안전   | -1        | 0.00             | 0%                |
| 보편   | 3         | 1.00             | 100%              |

---

🔔 **참고**:
- **음수 점수(안전)**: 선택했지만 상대적 점수가 낮아 정규화 시 **0점 처리**됨.
- **스케일 값**: 시각화 및 통계 해석 시 **0~100% 범위**로 사용.

---


## 해당 방식이 가지는 문제점

- 모든 키워드의 값이 양수일 경우 0~1사이로 정규화되기 때문에 가장 적은 점수를 가진 키워드에 대해서는 선택했음에도 불구하고 0으로 처리된다.
  - 따라서 선택했음에도 불구하고 선택되지 않은 것으로 보일 가능성 존재

```java
@DisplayName("키워드 점수를 정규화하여 0~100 스케일로 조정한다")
  @Test
  void keywordScoreScalePercent() {
    // given
    KeywordScore keywordScore1 =
        KeywordScore.builder().keyword(Keyword.BENEVOLENCE).score(BigDecimal.valueOf(1)).build();
    KeywordScore keywordScore2 =
        KeywordScore.builder().keyword(Keyword.SELF_DIRECTION).score(BigDecimal.valueOf(2)).build();
    KeywordScore keywordScore3 =
        KeywordScore.builder().keyword(Keyword.STABILITY).score(BigDecimal.valueOf(3)).build();
    // when
    List<KeywordScore> scores =
        KeywordScores.percentScale2(List.of(keywordScore1, keywordScore2, keywordScore3));
    // then
    BDDAssertions.then(scores)
        .extracting("keyword", "score")
        .containsExactlyInAnyOrder(
            tuple(Keyword.BENEVOLENCE, BigDecimal.valueOf(0).setScale(2)),
            tuple(Keyword.SELF_DIRECTION, BigDecimal.valueOf(50).setScale(2)),
            tuple(Keyword.STABILITY, BigDecimal.valueOf(100.0).setScale(2)));
  }
```

위의 테스트 코드는 모든 키워드의 값이 양수일 경우 0~1사이로 정규화되기 때문에 가장 적은 점수를 가진 키워드에 대해서는 선택했음에도 불구하고 0으로 처리된다는 것을 보여주는 코드입니다.

## 논의되어야 할 사항
- 어떠한 값을 넣어도 문제가 일어나지 않게 점수 스케일을 정할 수 있는 방법이 존재하는지 논의 필요
- 특정한 Keyword Score의 점수 분포를 지정해두고 해당 값 이내의 값만 사용하도록 제한

위의 해당 내용이 논의가 된다면 계산식이 변경 될 필요가 존재할 것 같습니다.

예시) 양수 값만 사용하도록 제한을 두었다면, 위의 계산식을 사용하더라도 상수값을 사용하여 최소값도 표현이 될 수 있도록 변경

```
정규화 값 = 상수 + (1-상수) * (점수 - 최소값) / (최대값 - 최소값)
```
